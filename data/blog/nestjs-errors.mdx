---
title: 'Ultimate Guide: NestJS Error Handling [Updated 2022]'
h1: 'NestJS error handling best practices'
date: '2022-07-24'
lastmod: '2022-07-24'
draft: true
summary: Learn the techniques and best practices for handling NestJS exceptions and errors by using automatic error logging, custom exception filters and more.
---

This tutorial covers best practices to use when handling errors in NestJS.

There are many considerations to make when throwing exceptions in a NestJS application:

- How to setup automatic logging when your application catches an error
- How to setup automatic logging of unhandled exceptions
- Throwing Axios exceptions
- Whether or not to throw http exceptions directly in the service layer
- How to handle the bubbling up of exceptions (should we catch them all in the controller layer?)
- How to leverage NestJS exception filters feature

This tutorial will cover the above points and more!

Ready? Let's dive in.

<TOCInline toc={props.toc} asDisclosure />

## Choose your logger

Before we dive in, it's worth noting in the below examples I'm using the Pino logger which is my [logger of choice in NestJS applications](/nestjs-logging).

If you're using a different logger, you'll still be able to follow along with the examples below, however, you'll need to tweak the usage of the logger class to it's specified implementation.

## Handling programmer errors

Programmer errors are the result of mistakes we make in our code.

The best way to explain a programmer error is by looking at an example.

Imagine in NestJS you're making an API call to a 3rd party service like this:

```ts
import { Injectable, Logger } from '@nestjs/common'

@Injectable()
export class PokemonService {
  constructor(private readonly httpService: HttpService) {}

  async findOne(id: number): Promise<string> {
    const pokemon = await this.httpService.axiosRef.get(`https://pokeapi.co/api/v2/pokemon/${id}`)
    return pokemon.data.name
  }
}
```

The above API call is **not** wrapped in a `try catch`.

What if the 3rd party API service is down? Or the API call returns an error?

In NestJS, this error will bubble up and either:

- Be caught. If you've caught and handled the error in your code (for example, in the controller layer), then it's an [operational error](#handling-operational-errors) rather than a programmer error.
- Not caught. If the error is not handled in your code, the error will bubble all the way up to the route handler where NestJS has a [built-in exceptions layer](https://docs.nestjs.com/exception-filters) to catch the unhandled error and automatically sends a 500 server error HTTP response. There are scenarios where allowing the error to bubble all the way up will be your intended behavior, but for now let's focus on the 'programmer error' scenario where you've forgotted to handle this error in your code.

It's a good idea to take the built-in NestJS exception layer a step further and automatically log the error everytime the error reaches this exception layer.

Otherwise, you won't have any visibility into the unhandled exceptions in your application.

To set this up, we can define a custom exception filter.

### Add a fallback exception filter

Add a file to your project called `fallback.filter.ts` and add the following code:

```ts:fallback.filter.ts
import { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common';

@Catch()
export class FallbackFilter implements ExceptionFilter {
  catch(exception: any, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();


    return response.status(500).json({
      status: 500,
      message: 'Internal server error',
    });
  }
}

```

The above code will catch all exceptions that bubble all the way up and return a 500 server error.

This is exactly the same functionality as the built-in exception filter, but by using a custom exception filter, we can add some custom logic.

Let's add some logging so every unhandled exception is logged (please note as mentioned above, I'm using the [Pino logger](/nestjs-logging) in the examples in this blog post).

```ts:fallback.filter.ts
import { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common';

@Catch()
export class FallbackFilter implements ExceptionFilter {
  catch(exception: any, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();

    const logger = new Logger('UnhandledException');
    logger.error(
      {
        ...(exception && { ...exception }),
        ...(exception.message && { message: exception.message }),
        ...(exception.stack && { stack: exception.stack }),
        ...(exception.code && { code: exception.code }),
      },
      `${exception.message ? exception.message : `Unhandled exception`}`,
    );


    return response.status(500).json({
      status: 500,
      message: 'Internal server error',
    });
  }
}

```

With Pino, passing in `UnhandledException` into the logger constructor sets a `context` property to the JSON log which will be very helpful when filtering the error logs.

The above logging implementation is one way of doing it. You should customise this to your needs based on what logger you're using and what data you want to pass into the error log!

Let's add this filter so it's applied globally in the NestJS application by using the `useGlobalFilters` method.

```ts:main.ts
import { NestFactory } from '@nestjs/core';
import { Logger, LoggerErrorInterceptor } from 'nestjs-pino';
import { AppModule } from './app.module';
import { FallbackFilter } from './filters/fallback.filter';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, { bufferLogs: true });
  app.useLogger(app.get(Logger));
  app.useGlobalInterceptors(new LoggerErrorInterceptor());
  app.useGlobalFilters(new FallbackFilter());
  await app.listen(3000);
}
bootstrap();

```

You can limit the scope of the filter rather than applying it globally if that's required for your implementation. Check out the [docs](https://docs.nestjs.com/exception-filters#binding-filters) for more info on how to do that.

So, we've now got some automatic error logging on unhandled exceptions. What next?

## Handling operational errors

By operational errors, I mean errors that you intentionally throw in your application.

- How to automatically log these operational errors
- Whether or not to throw http exceptions directly in the service layer
- Should we let these operatoinal errors bubble all the way up, or catch them all in the controller layer?

Here's an example of an operational error with an error log:

```ts
import { Injectable, Logger } from '@nestjs/common'

@Injectable()
export class PokemonService {
  private readonly logger = new Logger(MyService.name)

  async findOne(id: number): Promise<string> {
    try {
      // some code here
    } catch (error) {
      this.logger.error(error)
      throw new Error(error)
    }
  }
}
```

While this approach works, there are a couple of downsides:

- Us developers are lazy and manually logging errors is a pain
- Logging errors is super important, but the above approach does not enforce any consistencies across the logging which can help with debugging down the line.

Let's expore some ways to solve this.

### Could NestJS exception filters be the solution?

I've seen some suggestions in the NestJS community to add logging to a custom [NestJS exception filter](https://docs.nestjs.com/exception-filters) to solve the problem of automating error logs.

However, adding logging to a custom exception filter might not be the best approach either, as errors only pass through the filters that haven't been caught in your app (i.e. the error has bubbled all the way up).

For example, you might have a `try catch` within your service layer like this:

```ts
import { Injectable, Logger } from '@nestjs/common'

@Injectable()
export class PokemonService {
  async findOne(id: string): Promise<string> {
    try {
      // some code here
    } catch (error) {
      // catch the error here
    }
  }
}
```

And in the controller, you might want to always return a successful response to the client (even if the service layer catches an error):

```ts
import { Controller, Get, Param } from '@nestjs/common'
import { PokemonService } from './pokemon.service'

@Controller('pokemon')
export class PokemonController {
  constructor(private readonly pokemonService: PokemonService) {}

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<string> {
    try {
      return await this.pokemonService.findOne(+id)
    } catch (error) {
      return `default string`
    }
  }
}
```

In the above code, if an error is caught in the service layer, the controller will return `default string` to the client meaning the error will never reach the exception filter.

So if your automatic logging is set up via a custom exception filter, it won't handle the logging for any errors that don't bubble up.

This isn't ideal - we want to log all errors that thrown in the application so we have full visibility of all errors.

### Throwing custom errors

We need a different approach that logs the error everytime an error is thrown, not just when the error bubbles all the way up.

To achieve this, we can extend the [built-in error class](https://nodejs.org/api/errors.html#class-error) to create custom errors.

For example, here's a super simple custom error class:

```ts
export class BaseError extends Error {
  constructor(message: string) {
    super(message)
  }
}
```

The built-in error class takes in a `message` argument so that's why we've called `super` to pass in the message.

Typically, this message is then returned in the HTTP response to the client (we'll get to this later on).

So now when you throw an error you can use this custom error class:

```ts
throw new BaseError(`Something went wrong`)
```

We've still not automated the error logging, so let's extend our custom error class further:

```ts
import { Logger } from '@nestjs/common'

export class BaseError extends Error {
  constructor(message: string) {
    super(message)

    const logger = new Logger()
    logger.error(message)
  }
}
```

Now whenever we throw `BaseError` in our application, an error log with be automated!

While this approach handles the logging automation, the custom error above doesn't allow for:

- Passing in a specific log ID to help monitor the specific error
- Passing in a category of log (e.g. so you can group your logs by category)
- Passing in custom data to the error log (e.g. the stack trace, or user ID)
- Passing in a custom log message (it's likely that you'll want the log message to be different to the error message that's returned to the client in the HTTP response)

We can extend our `BaseError` further to add these features:

```ts
import { Logger } from '@nestjs/common'

export interface BaseErrorMeta {
  id: string
  service: string
  logMessage: string
  errorMessage?: string
  data?: object
}

export class BaseError extends Error {
  constructor(meta: BaseErrorMeta) {
    super(meta.errorMessage ? `${meta.errorMessage}` : `Internal server error`)

    const logger = new Logger(meta.service)
    logger.error(
      {
        id: meta.id,
        data: { ...meta.data },
        trace: this.stack,
      },
      meta.logMessage
    )
  }
}
```

You can obviously tweak the above custom error class to be more suited to your needs!

Here's an example of throwing `BaseError` in our application with the updated class:

```ts
import { BaseError } from 'src/errors/base.error'
import { Injectable } from '@nestjs/common'

@Injectable()
export class PokemonService {
  async findOne(id: number): Promise<string> {
    try {
      // some code here
    } catch (error) {
      throw new BaseError({
        id: 'find-one-pokemon', // unique ID for this error
        service: PokemonService.name,
        logMessage: `Error finding Pokemon: ${error}`, // message to be logged
      })
    }
  }
}
```

### Extending the custom error

### Validation errors

### Handling Axios errors

- example (Axios)

## Conclusion

In short, the strategy outlined above can be summarised in the following approach:

- Setup a fallback exception filter to automatically log 'programmer' errors
- Automatically log all 'operational' errors by using a custom error class (extended from the built-in error class)
- Add an exception filter that catches your custom errors that bubble all the way up and convert them to an appropiate HTTP status code.

What do you think? Do you have a different approach to handling errors in NestJS? Add a comment below.
